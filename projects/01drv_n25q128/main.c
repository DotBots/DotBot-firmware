/**
 * @file
 * @ingroup samples_drv
 * @author Alexandre Abadie <alexandre.abadie@inria.fr>
 * @brief This is an example on how to use the N25Q128 flash memory driver.
 *
 * @copyright Inria, 2024-present
 *
 */
#include <stdint.h>
#include <nrf.h>
#include <stdbool.h>

#include "board_config.h"
#include "gpio.h"
#include "n25q128.h"

#if defined(BOARD_NRF52833DK)
static const gpio_t _sck_pin  = { .port = 0, .pin = 23 };
static const gpio_t _miso_pin = { .port = 0, .pin = 22 };
static const gpio_t _mosi_pin = { .port = 0, .pin = 21 };
static const gpio_t _cs_pin   = { .port = 0, .pin = 20 };
#else
static const gpio_t _sck_pin  = { .port = 1, .pin = 15 };
static const gpio_t _miso_pin = { .port = 1, .pin = 14 };
static const gpio_t _mosi_pin = { .port = 1, .pin = 13 };
static const gpio_t _cs_pin   = { .port = 1, .pin = 12 };
#endif

#define READ_BUFFER_SIZE (256U)

static const n25q128_conf_t _n25q128_conf = {
    .mosi = &_mosi_pin,
    .sck  = &_sck_pin,
    .miso = &_miso_pin,
    .cs   = &_cs_pin,
};

static uint8_t read_buf[READ_BUFFER_SIZE] = { 0 };
// clang-format off
static uint8_t data[READ_BUFFER_SIZE]     = {
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
};
// clang-format on

int main(void) {
    n25q128_init(&_n25q128_conf);
    uint32_t address = 0x0;
    n25q128_base_address(&address);
    n25q128_sector_erase(address);
    n25q128_read(address, read_buf, READ_BUFFER_SIZE);
    n25q128_program_page(address, data, READ_BUFFER_SIZE);
    n25q128_read(address, read_buf, READ_BUFFER_SIZE);

    while (1) {
        __WFE();
    }
}
